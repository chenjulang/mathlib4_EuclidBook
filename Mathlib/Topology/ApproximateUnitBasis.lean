/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Topology.Bornology.Basic
import Mathlib.Topology.Basic

/-! # Approximate units

An *approximate unit* is a filter basis such that multiplication on the left (or right) by `m`
tends to `m` along the filter generated by the basis. In the case of normed rings, it is often
required that the elements of the basis are contained in the unit ball. In order to reduce the
type class burden, we instead only require a bornology on the underlying type, and a bounded
set containing all the elements of the basis.

Examples of approximate units include:

- The trivial approximate unit with filter basis `() ↦ {1}` in a normed ring.
- In a C⋆-algebra, the collection of sections `fun a ↦ {x | a ≤ x} ∩ ball 0 1`, where `a`
  ranges over the positive elements of norm strictly less than 1, is the filter basis for an
  approximate unit.

## Main declarations

+ `Filter.mulLeftRightTendsto`: the largest filter `l` such that `Tendsto (· * m) l (𝓝 m)`
  and `Tendsto (m * ·) l (𝓝 m)` for all `m`.
+ `ApproximateUnit`: a filter smaller than `Filter.mulLeftRightTendsto` with a basis all of whose
  elements are contained in a given bounded set.

## Implementation details

Unlike most areas of the library, it is actually not the *filter* itself that is important, but
rather the filter basis. Indeed, the only property relevant to the filter is that it is smaller
than `Filter.mulLeftRightTendsto`. Moreover, in the case of C⋆-algebras, one always uses properties
of the filter basis (e.g., that the sets are contained in the intersection of the positive cone
and the unit ball). For this reason, we define `ApproximateUnit` as a structure extending
both `Filter` and `Filter.HasBasis`, and we provide a convenience constructor for `Filter.IsBasis`.

-/

open Filter Topology Bornology

section Def

variable {α ι : Type*} [TopologicalSpace α] [Mul α]

namespace Filter

/-- The largest filter `l` such that `Tendsto (· * m) l (𝓝 m)` and `Tendsto (m * ·) l (𝓝 m)` -/
@[to_additive "The largest filter `l` such that `Tendsto (· + m) l (𝓝 m)` and
`Tendsto (m + ·) l (𝓝 m)`"]
def mulLeftRightTendsto : Filter α :=
  sSup { l : Filter α | ∀ (m : α), Tendsto (· * m) l (𝓝 m) ∧ Tendsto (m * ·) l (𝓝 m) }

@[to_additive]
lemma mulLeftRightTendsto.tendsto_mul_left (m : α) :
    Tendsto (· * m) mulLeftRightTendsto (𝓝 m) := by
  simp_rw [mulLeftRightTendsto, tendsto_def, mem_sSup]
  aesop

@[to_additive]
lemma mulLeftRightTendsto.tendsto_mul_right (m : α) :
    Tendsto (m * ·) mulLeftRightTendsto (𝓝 m) := by
  simp_rw [mulLeftRightTendsto, tendsto_def, mem_sSup]
  aesop

@[to_additive]
lemma mulLeftRightTendsto.le_iff {l : Filter α} :
    l ≤ mulLeftRightTendsto ↔ ∀ m, Tendsto (· * m) l (𝓝 m) ∧ Tendsto (m * ·) l (𝓝 m) :=
  ⟨fun h m ↦ ⟨(tendsto_mul_left m).mono_left h, (tendsto_mul_right m).mono_left h⟩,
    fun h ↦ le_sSup h⟩

end Filter

variable [Bornology α]

/-- An *approximate unit* is a filter smaller than `mulLeftRightTendsto` along with a basis
consisting of sets contained in a given bounded set. The former condition is equivalent to the
condition that for all `m`, multiplication on the left (or right) tends to `m` along the filter.

Note: this extends `Filter` and `Filter.HasBasis` rather than taking the filter as an argument.
This is because, in many cases, the only interesting property of the filter is that it is smaller
than `mulLeftRightTendsto` and we may only be interested in the filter basis itself. -/
structure ApproximateUnit (p : ι → Prop) (s : ι → Set α)
    extends Filter α, toFilter.HasBasis p s where
  /-- The filter generated by the basis is smaller than `Filter.mulLeftRightTendsto`. -/
  filter_le : toFilter ≤ mulLeftRightTendsto
  /-- All elements of the basis are bounded. -/
  bounded : ∃ t, IsBounded t ∧ ∀ i, p i → s i ⊆ t
  /-- The filter generated by the basis is not `⊥`. -/
  protected [neBot : NeBot toFilter]

/-- Create an approximate unit from a filter basis satisfying the necessary properties. -/
@[simps toFilter toHasBasis]
def Filter.IsBasis.approximateUnit {p : ι → Prop} {s : ι → Set α} (b : IsBasis p s)
    (h_le : b.filter ≤ mulLeftRightTendsto)
    (h_bdd : ∃ t, Bornology.IsBounded t ∧ ∀ i, p i → s i ⊆ t)
    (h_neBot : ∀ i, p i → (s i).Nonempty) : ApproximateUnit p s where
  toFilter := b.filter
  toHasBasis := b.hasBasis
  filter_le := h_le
  bounded := h_bdd
  neBot := by rwa [b.hasBasis.neBot_iff]

variable {p : ι → Prop} {s : ι → Set α}

lemma tendsto_mul_left (au : ApproximateUnit p s) (m : α) :
    Tendsto (· * m) au.toFilter (𝓝 m) :=
  mulLeftRightTendsto.le_iff.mp au.filter_le m |>.1

lemma tendsto_mul_right (au : ApproximateUnit p s) (m : α) :
    Tendsto (m * ·) au.toFilter (𝓝 m) :=
  mulLeftRightTendsto.le_iff.mp au.filter_le m |>.2

end Def

/-- A unital magma with a topology and bornology has the trivial approximate unit `𝓟 {1}` with
basis `{1}`. -/
@[simps toFilter toHasBasis]
def ApproximateUnit.ofUnit (α : Type*) [TopologicalSpace α] [MulOneClass α] [Bornology α] :
    ApproximateUnit (fun _ => True) (fun _ : Unit => {(1 : α)}) where
  toFilter := 𝓟 {1}
  toHasBasis := Filter.hasBasis_principal {1}
  filter_le := by simpa [mulLeftRightTendsto.le_iff, tendsto_pure_left]
    using fun _ _ ↦ mem_of_mem_nhds
  bounded := ⟨{1}, by simp⟩
  neBot := principal_neBot_iff.2 <| Set.singleton_nonempty 1

section DirectedOn

/-- If `s : Set α` is a nonempty directed set, then the collection of sections `{x | · ≤ x} ∩ s`
contained in `s` forms a basis for a filter on `α`. -/
lemma DirectedOn.filterIsBasis {α : Type*} [Preorder α] {s : Set α}
    (h : DirectedOn (· ≤ ·) s) (hs : s.Nonempty) :
    Filter.IsBasis (· ∈ s) ({x | · ≤ x} ∩ s) where
  nonempty := hs
  inter {x y} hx hy := by
    obtain ⟨z, hz, hxz, hyz⟩ := h x hx y hy
    refine ⟨z, hz, fun w hw ↦ ?_⟩
    have : x ≤ w ∧ y ≤ w := ⟨hxz.trans hw.1, hyz.trans hw.1⟩
    aesop

end DirectedOn
